[08/05/2019]

Exam 2 grade requests sent to me so far have been processed. 
A response was only sent in cases of additional information being needed or 
the answer being "no".

School of Science ice cream social this Wednesday - see poster under Course
Materials for lec-7-22/

Final Exam review packet will be released this week. Hopefully we will have
some time left next week to go over parts of it.

Final Exam will be a 2 hour test during Thursday 8/15 lecture. You can attend
either section.
If you have accomodations that are the same as during Exam 2, you do not need 
to e-mail me, just assume the same arrangement.

Homework 4 submission is now open on Submitty.
====================

MEMORY MANAGEMENT

Memory Manager:

-- allocate/deallocate memory for processes
	(the OS assigns memory to new/running processes and deallocates memory)

-- protection, i.e., no access to a given process's memory space
		from outside the given processes

-- shared memory management (between two or more processes, which could include
		shared libraries, shared memory segments created via shmget(), etc. )

Approaches:
-- Continguous Memory Allocation
-- Noncontinguous Memory Allocation
-- Virtual Memory

With multiprogramming, multiple options for managing memory

-- early approaches identified PARTITIONS, where a parition is a block
	of CONTIGUOUS MEMORY that can be allocated to a process

Degree of multiprogramming
-- how many processes can be in memory at once?
-- depends on process size, partition size, and the amount of memory available
		overall. (If we're thinking about the dynamics, then run time of processes)

A LOGICAL ADDRESS references some location within a given process space
	-- think of the logical address as an offset from the first byte of
			the process memory (byte 0)

				LOAD x
 LABEL: ...
				...
				...
				DECR x			; x--
				BNE LABEL		; branch up/backwards 48 bytes

	-- RELOCATABLE CODE

	-- When a process is placed into physical memory,
			its logical address space is bound to a physical memory space

The OS must map every LOGICAL ADDRESS to a PHYSICAL ADDRESS
-- logical addresses are generated by compilers/assemblers

CONTIGUOUS MEMORY ALLOCATION
-- fit the entire process address space into physical memory in
	 one contiguous (uninterrupted) block

		-- this block has a BASE address (e.g., 14000) or starting point
				in physical memory, as well as a LIMIT (size in bytes)

-- Partioned memory can be FIXED or DYNAMIC

Fixed Partioning Scheme
-- Given N partitions of potentially different sizes
-- Each process is allocated to exactly one partition
-- Each partition is associated with one process OR is marked FREE
-- OS manage a list of free partitions and
		a mapping of used partitions to processes

MEMORY (fixed partitioning scheme):
-----------------------------------
 DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD    Partition 1  (64 memory units)
 DDDDDDDDDDDDDDDDDDDDDDDDDD.......
-----------------------------------
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB    Partition 2  (64 memory units)
 BBBBBBBBBBB......................
-----------------------------------
 CCCCCCC..........................    Partition 3  (256 memory units)
 .................................
 .................................
 .................................
 .................................
 .................................
 .................................
 .................................
-----------------------------------

-- if process E arrives and requires 8 memory units, we cannot allocate
	 a partition for this process because all partitions are in use
	 (even though there is a lot of free space left)

Dyanmic Partitioning Scheme
-- the size of a given process will define the size of the allocated partition
		(or more specifically the size requested by a process)
-- this is essentially on-demand partitioning

MEMORY (dynamic partitioning scheme):
-----------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBB   The set of A's defines one partition
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB    (for process A), the set of B's defines
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB     another partition, etc.
 BCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC.
 ....MMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM...............
 .................................   As time goes by, processes arriving
 .................FFFFFFFFFFFFFFFF    and leaving the system cause the memory
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF     to become increasingly fragmented
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 FGGGGGGGGGGGGGGGGGGGG............
 ................HHHHHHHHHH.......
-----------------------------------

If process X arrives and requires more memory than the largest free partition,
 we look to defragmentation.

MEMORY (after defragmentation / memory compaction):
-----------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMFFFFFFFFFFFFFFFFFFFF
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFGGG
 GGGGGGGGGGGGGGGGGHHHHHHHHHH......
 .................................
 .................................  
 .................................  
-----------------------------------

MEMORY (after defragmentation / memory compaction):
-----------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCM
 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMFFFFFFFFFFFFFFFFFFFF
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFGGG
 GGGGGGGGGGGGGGGGGHHHHHHHHHHXXXXXX
 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  
 XXXXXXXXXXXXXXXXXXXXXXXXXXX......  
-----------------------------------

We need an algorithm to determine where to place each newly arriving process
--e.g. proces Y arrives and requires 6 memory units

FIRST-FIT ALGORITHM
-- scan from the "top" of memory until we find
		a free partition that fits process Y

MEMORY (first-fit):
-----------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC.
 ....MMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMYYYYYY.........
 .................................  
 .................FFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 FGGGGGGGGGGGGGGGGGGGG............
 ................HHHHHHHHHH.......
-----------------------------------

NEXT-FIT ALGORITHM
-- scan from the end of the most recently placed process
		until we find a free partition that fits process Y

		e.g. assume F was the last process placed

MEMORY (next-fit):
-----------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC.
 ....MMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM...............
 .................................  
 .................FFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 FGGGGGGGGGGGGGGGGGGGGYYYYYY......
 ................HHHHHHHHHH.......
-----------------------------------

BEST-FIT ALGORITHM
-- allocate process Y to the smallest free partition
		that's big enough to fit process Y

MEMORY (best-fit):
-----------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC.
 ....MMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMM...............
 .................................  
 .................FFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 FGGGGGGGGGGGGGGGGGGGG............
 ................HHHHHHHHHHYYYYYY.  <=== place process Y here (best fit), with
-----------------------------------      the hope that if a larger process arrives,
																				 we can still place it

WORST-FIT ALGORITHM
-- allocate process Y to the largest free partition
		that can fit process Y

MEMORY (worst fit):
-----------------------------------
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB  
 BCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC.
 ....MMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 MMMMMMMMMMMMMMMMMMYYYYYY.........
 .................................  
 .................FFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 FGGGGGGGGGGGGGGGGGGGG............
 ................HHHHHHHHHH.......
-----------------------------------

 -- does worst-fit give us the benefit of delaying the need for defragmentation?
         ^^^^^^^^^
        any algorithm

==================================================

NON-CONTIGUOUS MEMORY ALLOCATION

-- We avoid the need to defragment memory by using a non-contiguous approach

-- Given process P, we slice up the process into N equally sized PAGES
	(where the last page might not use the entire page of logical memory)

-- Next, we allocate each PAGE to a FRAME of physical memory
	(i.e., frame size == page size)

-- But .... we do need a way to map logical address to physical address

	-- we implement this mapping using a PAGE TABLE --- overhead...

e.g., a 16-bit memory address with the high-order 4 bits representing
	the page number

	logical address: 0110110011001111 <== binary 16-bit address



                       |
	logical address: 0110|110011001111 <== binary 16-bit address
                    ^  |     ^
                    |        |
                    |        |
                   page     page
                  number   offset

					...do the lookup in the page table for page 0110 (6)
					which for this process maps to (say...) frame 1101 (13)

                  frame    frame
                  number   offset
                    |        |
                    |        |
                    v  |     v
	logical address: 1101|110011001111 <== binary 16-bit address
                       |

	At most, how many pages are there per process?

	 4
	2  = 16 pages

	What is the page size ( and therefore the frame size ) in bytes?

   12
	2   = 4096 bytes

	Invariant: page size == frame size

	On a modern system, how many pages do we have? 32-bit? 64-bit?

	32-bits w/ 4KB pages
	32-12 = 20 bits for page number

	 20
	2   =  1M pages

	64-bit w/ 4KB pages
	64-12 = 52 bits for page number

	 52
	2   = many pages   (4 petapages)

